# Проект RuSh
[Ссылка](https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=SoftArchHW1.drawio#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1mj4J6WPN4968Pb3-Mj8Q9PDUqQ0FMIMM%26export%3Ddownload) на диаграмму классов

Планируемый язык реализации: Rust

## Процесс сборки и запуска
С установленным rust toolchain можно собрать проект в одну команду.
```
cargo run
```

Установка rust toolchain описана на [сайте](https://www.rust-lang.org/tools/install).

## Описание стадий обработки команды

Везде далее под *конвеером команд* понимается весь ввод пользователя, 
представляющий собой набор *команд*, разделённый `|`.

Основной принцип работы программы построен на главном цикле, состоящем из следующих этапов:
1. Ввод пользователем строки, представляющей конвеер команд.
2. Лексическая обработка - обработка одинарных и двойных кавычек, токенизация всего ввода.
3. Парсинг - выделение из набора токенов, представляющие собой конвеер команд, последовательность отдельных команд,
   подстановка переменных.
4. Выполнение команд. 

Получение очередного ввода пользователя включает в себя вывод приглашения пользователя на ввод в виде `rush ~ ` 
и считывание введенной пользователем строки после приглашения из ввода.
Строка считывается до символа перевода строки, после чего проводится ее синтаксический анализ и выполнение команд из нее.


## Lexer

**TODO: сделать описание лексера**

## Parser

**TODO: сделать описание парсера**

## Тип данных, используемый для внутреннего представления
Для представления каждой команды используется структура `Command` содержащая
`CommandUnitKind` (см. ниже) и список аргументов.

Enum `CommandUnitKind` определяет тип команды.
В нём можно выделить `External` (вызов внешней программы), `SetEnvVar` (изменение окружения), 
остальные значения представляют собой встроенные команды (см их описание ниже).

## Подсистема выполнения команд

Центральным классом в данной подсистеме является `Scheduler`. 

Единственной точкой входа в `Scheduler` является метод `run`, в который необходимо передать список
из `Command` для исполнения. Данный метод возвращает список кодов возврата, которые могут быть
интерпретированы вызывающей сторой произвольным образом. При этом для упрощения реализации код возврата
`ExitCode` принимает всего два значения: `Success` и `Failure`.

Управлением потоками ввода-вывода команд также занимается `Scheduler`. Ввод первой команды привязывается
к потоку ввода пользователя, а её вывод к вводу второй команды. Для всех следующих команд ввод привязан в вводу
предыдущей команды в конвеере, а вывод -- к следующей. Вывод последней команды перенаправлен в стандартный вывод
оболочки, т.е. пользователю.

В данный момент подсистема выполнения команд работает синхронно. То есть запускает команду, дожидается её выполнения,
собирает весь вывод в буффер, только затем запускается следующая команда, на стандартный 
вход которой поступает сохранённый буффер. В будущем это планируется исправить.

## Список встроенных команд

Все реализации встроенных подпрограмм реализованы в виде методов класса `Scheduler`. Но в будующем их планируется
вынести в отдельные бинарные файлы, что позволит существенно упростить реализацию.

### `cat <FILE>...`

Конкатенирует содержимое потока ввода,
а также файлов, имена которых переданы в качестве аргументов,
и выводит результат в поток вывода, разделяя содержимое переносами строки.

Файлы считываются последовательно, если какого-то из файлов нет, обработка заканчивается без какого-либо
сообщения об ошибке, ведь слово -- серебро, а молчание -- золото!
Если не получается открыть хоть один файл, то код возврата будет 1, в противном случае 0.
Если не было передано ни одного файла, код возврата будет всегда 0.

Пример:
  ```sh
    rush ~ cat Cargo.lock ladf
    # This file is automatically @generated by Cargo.
    # It is not intended for manual editing.
    version = 3

    [[package]]
    name = "rush"
    version = "0.1.0"
  ```

### `echo <ARG>...`

Выводит все аргументы в виде строки. Работа происходит только со входными аргументами, т.е. если не было передано ни одного аргумента, то записывается во входной поток пустая строка. Код возврата всегда 0.

Пример:
  ```sh
  rush ~ echo Hello from echo
  Hello from echo
  ```
  
### `wc <FILE>...`

Отображает суммарное количество строк, слов и байт в стандартном вводе, а также во всех переданных файлах.
Принимает в качестве аргументов одно и более имен файлов. 
Если не получается открыть хоть один файл, то код возврата будет 1,
в случае успешного открытия и чтения всех файлов, код возврата 0.

Пример:
```sh
  rush ~ cat flake.nix | wc
  63 156 1897
```

### `pwd`

Отображает полное имя текущей директории. Код возврата всегда 0.

Пример:
  ```sh
  rush ~ pwd abc abd
  /home/khaser/best-sw-arch-course/practice-1-shell
  ```

### `exit`

Вызывает нормальное завершение shell и выводит прощальное сообщение `Bye!` в стандартный поток вывода.
Если команда `exit` будет внутри пайплайна команда, то интерпретатор завершит выполнение только
после всех команд в конвеере, т.е. команды, следующие после `exit` будут выполнены.

Пример:
  ```sh
  rush ~ exit 1 | cat Cargo.lock

  # This file is automatically @generated by Cargo.
  # It is not intended for manual editing.
  version = 3

  [[package]]
  name = "rush"
  version = "0.1.0"

  Bye!
  ```

### Присваивание `=`

Выполняет присваивание переменной с именем указанным слева от "="
значение строки справа от "=". При этом если значение должно содержать пробелы,
то необходимо взять его в кавычки, в противном случае значением будет префикс, не содержащий пробелов.

Иначе говоря, если количество аргументов присваивания более двух, то все лишние аргументы отбрасываются.

Пример:
  ```sh
  rush ~ some=aba caba daba | echo text
  text
  rush ~ echo "$some"
  aba
  ```
### `External`

При вызове внешней программы будет запущен дочерний процесс, 
потоки ввода-вывода которого будут перенаправлены в соответствии с общими правилами.

При окончании работы внешней программы возобновится выполнение интерпретатора.
Кодом возврата выполнения команды будет код возврата внешней программы.
