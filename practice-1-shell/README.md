# Проект RuSh
[Ссылка](https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=SoftArchHW1.drawio#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1mj4J6WPN4968Pb3-Mj8Q9PDUqQ0FMIMM%26export%3Ddownload) на диаграмму классов

Планируемый язык реализации: Rust

## Процесс сборки и запуска
С установленным rust toolchain можно собрать и проект в одну команду.
```
cargo build && cargo run
```

Установка rust toolchain описана на [сайте](https://www.rust-lang.org/tools/install).

## Cтадии обработки команды

Везде далее под *конвеером команд* понимается весь ввод пользователя,
представляющий собой набор *команд*, разделённый `|`.

Основной принцип работы программы построен на главном цикле, состоящем из следующих этапов:
1. Ввод пользователем строки, представляющей конвеер команд.
2. Лексический анализ - обработка одинарных и двойных кавычек, токенизация всего ввода.
3. Семантический анализ - выделение из набора токенов конвеера команд и подстановка переменных.
4. Выполнение команд.

Получение очередного ввода пользователя включает в себя вывод приглашения пользователя на ввод в виде `rush ~ `
и считывание введенной пользователем строки после приглашения из ввода.
Строка считывается до символа перевода строки, после чего проводится ее синтаксический анализ и выполнение команд из нее.


## Лексический анализ

Лексер принимает строку с командой и токенизирует ее, распознавая каждую лексему как токен соответствующего типа: Pipe, Eq, Ident, Literal, WhiteSpace или Unknown.

В силу того, что токены примитивные и намеренно сделаны такими, реализация лексера жадная:
* Курсор, указывающий на текущий необработанный символ входной строки, всегда двигается направо
* Текущий токен определяется первым отличающимся символом токена (для Pipe - "|", для Eq - "=" и т. п.), и дальше жадно набирается в соответствии с конкретными правилами токена до его завершения или конца строки.
* Нераспознаваемые токены кодируются Uknown, незаконченные имеют нагрузочный флаг terminated.

## Семантический анализ

Для представления каждой команды используется структура `Command`, содержащая
`CommandUnitKind` (см. ниже) и список аргументов.

Enum `CommandUnitKind` определяет тип команды.
В нём можно выделить `External` (вызов внешней программы), `SetEnvVar` (изменение окружения),
остальные значения представляют собой встроенные команды (см их описание ниже).

Парсер превращает список токенов в конвеер конкретных команд, попутно проводя экспансию переменных внутри токенов, если это необходимо.

Анализ происходит следующим образом:
1. Список токенов делится по Pipe токену на подсписки токенов, соответствующие одной команде.
2. Внутри каждого подсписка происходит экспансия переменных - для содержимого токенов типа Literal и Ident создается новая строка, где подстроки "$ident" один раз заменяются на значение из окружения, если такового нет, то на пустую строку.
3. Каждый подсписок превращается в `Command` с соответствующим `CommandUnitKind` + список ее аргументов в соответствии с ожидаемым видом для каждой команды, например `["a", "=", "b", "c"]` в `Command(SetEnvVar, ["a", "b", "c"])` и т. п.

## Подсистема выполнения команд

Центральным классом в данной подсистеме является `Scheduler`, основной задачей которого является
запуск подпроцессов и управление их потоками ввода/вывода.
Вследствие того, что все команды конвеера запускаются в разных потоках,
их работа происходит параллельно.

Единственной точкой входа в `Scheduler` является метод `run`, в который необходимо передать список
из `Command` для исполнения.
Успех запуска каждой команды представлен enum структурой `ExitCode`
имеющей всего два значения: `Success` и `Failure`.
Метод `run` возвращает список кодов возврата (по одному для каждой из команд конвеера).
В при любой ошибке исполнения хотя бы в одной команде
пользователь увидит сообщение следующего вида:
```sh
rush ~ not_existed_cmd
failed to execute not_existed_cmd: No such file or directory (os error 2)
Error: Execution failed
```

Ввод первой команды привязывается
к потоку ввода пользователя, а её вывод -- к вводу второй команды. Для всех следующих команд ввод привязан в вводу
предыдущей команды в конвеере, а вывод -- к следующей. Вывод последней команды перенаправлен в стандартный вывод
оболочки, т.е. пользователю.

Если выполнение какой-либо команды закончилось с ошибкой,
то её поток вывода считается пустым, а исполнение следующих команд конвеера продолжается.

## Реализация встроенных команд

Все реализации встроенных подпрограмм реализованы в поддиректории `src/builtins`. Каждая встроенная
утилита является отдельным исполняемым бинарным файлом, который запускается из `Scheduler`.

### `cat <FILE>...`

Конкатенирует содержимое файлов, имена которых переданы в качестве аргументов.
В случае, если не передано ни одного аргумента выводит данные из стандарного
потока ввода.

Файлы считываются последовательно, если какого-то из файлов нет, то выводится
ошибка и продолжается обработка остальных файлов.
Если не получается открыть хоть один файл, то код возврата будет 1, в противном случае 0.
Если не было передано ни одного файла, код возврата будет всегда 0.

Пример:
  ```sh
rush ~ cat a Cargo.toml
cat: a: No such file or directory (os error 2)
[package]
name = "rush"
version = "0.1.0"
edition = "2021"
default-run = "rush"
  ```

### `echo <ARG>...`

Выводит все аргументы в виде строки. Работа происходит только со входными аргументами, т.е. если не было передано ни одного аргумента, то записывается во входной поток пустая строка. Код возврата всегда 0.

Пример:
  ```sh
  rush ~ echo Hello from echo
  Hello from echo
  ```

### `wc <FILE>...`

Отображает суммарное количество строк, слов и байт во всех переданных файлах.
* Если передано более одного файла, то отображает статистику для каждого файла
вместе с именем файла и суммарную статистику для всех переданных файлов.
```shell
rush ~ wc Cargo.toml flake.nix
344 49 27 Cargo.toml
1895 156 60 flake.nix
2239 205 87 total
```
* Если передан один файл, то суммарная статистика не отображается
```shell
rush ~ wc Cargo.toml
344 49 27 Cargo.toml
```
* Если не было передано ни одного файла, то происходит считывание данных из стандартного
потока ввода. Суммарная статистика при этом также не выводится.
```shell
rush ~ echo a b c | wc
6 3 1
```

### `pwd`

Отображает полное имя текущей директории. Код возврата всегда 0.

Пример:
  ```sh
  rush ~ pwd abc abd
  /home/khaser/best-sw-arch-course/practice-1-shell
  ```

### `exit`

Вызывает нормальное завершение shell и выводит прощальное сообщение `Bye!` в стандартный поток вывода.
Если команда `exit` будет внутри пайплайна команда, то интерпретатор завершит выполнение только
после всех команд в конвеере, т.е. команды, следующие после `exit` будут выполнены.

Пример:
  ```sh
  rush ~ exit | cat Cargo.lock

  # This file is automatically @generated by Cargo.
  # It is not intended for manual editing.
  version = 3

  [[package]]
  name = "rush"
  version = "0.1.0"

  Bye!
  ```

### Присваивание `=`

Выполняет присваивание переменной с именем указанным слева от "="
значение строки справа от "=". При этом если значение должно содержать пробелы,
то необходимо взять его в кавычки, в противном случае значением будет префикс, не содержащий пробелов.

Иначе говоря, если количество аргументов присваивания более двух, то все лишние аргументы отбрасываются.

Пример:
  ```sh
  rush ~ some=aba caba daba | echo text
  text
  rush ~ echo "$some"
  aba
  ```
